```
# gSim.py
#
# 3D gravity simulator written in Python
# uses pyGame and custom 3D projection code
#
# Mason X was here (2015)
#

# required imports
import pygame
from pygame.locals import RESIZABLE
import sys
from random import randint
from math import sqrt, log
import time

"""
Particle class
Contains speed, acceleration, and distance for x, y and z axis
Also contains mass and area of the particle.

@property px: position on X axis
@property py: position on Y axis
@property pz: position on Z axis
@property vx: speed on X axis
@property vy: speed on Y axis
@property vz: speed on Z axis
@property ax: acceleration on X axis
@property ay: acceleration on Y axis
@property az: acceleration on Z axis
@property mass: mass of the particle
@property area: surface area of the particle
"""
class Particle:
    def __init__(self, x, y, z, mass, area):
        self.px = x
        self.py = y
        self.pz = z
        self.mass = mass
        self.area = area
        self.vx = 0
        self.vy = 0
        self.vz = 0
        self.ax = 0
        self.ay = 0
        self.az = 0

# Screen size and other properties (make it resizable)
SCREEN_SIZE = (800, 600)
halfwidth  = SCREEN_SIZE[0]/2
halfheight = SCREEN_SIZE[1]/2
screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE)

# Clock so we can control FPS
clock = pygame.time.Clock()
# initialize pygame
pygame.init()

# particle array and length
NUM_PARTICLES = 400
particles = []

# Big G of this universe (gravitational constant)
# For the universe that humans live in, it's around 6.674×10^−11 [1]
# More information: [1] https://en.wikipedia.org/wiki/Gravitational_constant
BIGG = 0.001

# fill particle array with random locations
for i in range(0, NUM_PARTICLES):
    particles.append(Particle(randint(0, halfwidth), randint(0, halfheight), randint(20, 70), 10, 2))

# Running var to know when we quit
running = 1

# variable to see how much time has elapsed
lastTime = time.time()

# fov, viewer distance, and maximum distance for perspective projection
fov = 120
viewDist = 100
maxDist = 100

while running:
    # limit fps so computer won't go wild
    clock.tick(30)

    # get the delta time for the loop
    t = (time.time() - lastTime) * 1000
    lastTime = time.time()

    # clear the screen
    screen.fill((0, 0, 0))

    # Check events
    ev = pygame.event.get()
    for event in ev:
        # mouse clicked
        if event.type == pygame.MOUSEBUTTONUP:
            # get mouse position
            pos = pygame.mouse.get_pos()
            # create new particle at the position
            particles.append(Particle(pos[0]-halfwidth, pos[1]-halfheight, 1, randint(0, 100), 2))
            NUM_PARTICLES += 1
            # assign it a random speed
            particles[NUM_PARTICLES-1].vx = randint(-100, 100) / 1000
            particles[NUM_PARTICLES-1].vy = randint(-100, 100) / 1000
            particles[NUM_PARTICLES-1].vz = randint(0, 10) / 1000
        # screen size changed
        elif event.type == pygame.VIDEORESIZE:
            screen = pygame.display.set_mode((event.w,event.h), RESIZABLE)
            halfwidth  = SCREEN_SIZE[0]/2
            halfheight = SCREEN_SIZE[1]/2

    # loop through particles and calculate all the new accelerations and speeds
    for i in range(0, NUM_PARTICLES):
        # current particle
        currParticle = particles[i]

        # ignore particle with 0 mass
        if currParticle.mass == 0:
            continue

        # reset accelerations
        currParticle.ax = 0
        currParticle.ay = 0
        currParticle.az = 0

        # loop through all other particles
        for j in range(0, NUM_PARTICLES):
            # Ignore calculations with yourself
            if i == j:
                continue
            calcParticle = particles[j]
            # Ignore particle with 0 mass since they don't affect
            if (calcParticle.mass == 0):
                continue

            # for the math explanation, please visit https://s.masonx.ca/fetchProject.html?file=gSim/formulae
            dx = calcParticle.px - currParticle.px
            dy = calcParticle.py - currParticle.py
            dz = calcParticle.pz - currParticle.pz
            r = sqrt(dx*dx + dy*dy + dz*dz)

            # particles have collided
            if r < 5:
                newMass = currParticle.mass + calcParticle.mass
                currParticle.vx = (currParticle.mass * currParticle.vx + calcParticle.mass * calcParticle.vx) / newMass
                currParticle.vy = (currParticle.mass * currParticle.vy + calcParticle.mass * calcParticle.vy) / newMass
                currParticle.vz = (currParticle.mass * currParticle.vz + calcParticle.mass * calcParticle.vz) / newMass

                currParticle.mass = newMass
                currParticle.area = int(log(newMass))

                # make the calcparticle no longer exist
                calcParticle.mass = 0
                continue

            currParticle.ax += BIGG * calcParticle.mass * dx / (r*r*r)
            currParticle.ay += BIGG * calcParticle.mass * dy / (r*r*r)
            currParticle.az += BIGG * calcParticle.mass * dz / (r*r*r)

        currParticle.vx += currParticle.ax * t
        currParticle.vy += currParticle.ay * t
        currParticle.vz += currParticle.az * t

    # loop through particle array and increase x,y,z based on speed and draw them
    for i in range(0, NUM_PARTICLES):
        currParticle = particles[i]

        # Check if particle exists or not
        if (currParticle.mass == 0):
            continue

        # increase the distances
        currParticle.px += currParticle.vx * t
        currParticle.py += currParticle.vy * t
        currParticle.pz += currParticle.vz * t

        # ignore particles that are too far to see
        if currParticle.pz < 0 or currParticle.pz > maxDist:
            continue

        # project the things - http://codentronix.com/2011/04/20/simulation-of-3d-point-rotation-with-python-and-pygame/
        factor = fov / (viewDist + currParticle.pz)

        realx = currParticle.px * factor + halfwidth
        realy = currParticle.py * factor + halfheight
        scalesize = (maxDist / currParticle.pz)

        if scalesize > 2.5:
            scalesize = 2.5

        color = (255, 255, 255)

        # redshift and blueshift
        if currParticle.az > 0.001:
            color = (255, 0, 0)
        if currParticle.az < -0.001:
            color = (0, 0, 255)

        # draw the particle
        pygame.draw.ellipse(screen, color, [int(realx), int(realy), currParticle.area*scalesize, currParticle.area*scalesize])

    # flip screen (update)
    pygame.display.flip()
```
